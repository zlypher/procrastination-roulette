import {
  Alert,
  AlertDescription,
  AlertIcon,
  Box,
  Button,
  Container,
  Flex,
  Grid,
  Heading,
  Input,
  Select,
  Stack,
  Text,
} from "@chakra-ui/react";
import { motion } from "framer-motion";
import type { NextPage } from "next";
import Head from "next/head";
import Image from "next/image";
import { useEffect } from "react";
import { useRef } from "react";
import { useState } from "react";

const MotionBox = motion(Box);

const containerVariant = {
  normal: {},
  spin: {
    transition: {
      staggerChildren: 0.2,
    },
  },
};

const taskVariant = {
  normal: {},
  spin: {
    scale: 1.1,
    transition: {
      repeatType: "reverse",
      ease: "linear",
      duration: 0.4,
      repeat: Infinity,
    },
  },
};

interface ITaskProps {
  task: TTask;
  isResult: boolean;
}

const Task = ({ task, isResult }: ITaskProps) => {
  const elRef = useRef(null);

  useEffect(() => {
    if (isResult) {
      // TODO: scroll into view
    }
  }, [isResult]);

  return (
    <MotionBox variants={taskVariant} minWidth="0">
      <Flex
        ref={elRef}
        borderRadius="sm"
        boxShadow="lg"
        border={isResult ? "2px" : "1px"}
        p="2"
        alignItems="center"
      >
        <Text
          flexGrow={1}
          whiteSpace="nowrap"
          overflow="hidden"
          textOverflow="ellipsis"
          mr="4"
        >
          {task.name}
        </Text>
      </Flex>
    </MotionBox>
  );
};

type TTask = {
  name: string;
  prio: number;
};

const Home: NextPage = () => {
  const nameRef = useRef<HTMLInputElement>();
  const prioRef = useRef<HTMLSelectElement>();
  const [tasks, setTasks] = useState<TTask[]>([]);
  const [result, setResult] = useState<TTask | null>(null);

  const addTask = () => {
    if (nameRef.current == null || prioRef.current == null) {
      return;
    }

    const t: TTask = {
      name: nameRef.current.value,
      prio: parseInt(prioRef.current.value ?? 0, 10),
    };

    setResult(null);
    setTasks((prevTasks: TTask[]) => {
      return [...prevTasks, t];
    });

    nameRef.current.value = "";
    prioRef.current.value = "1";
    nameRef.current.focus();
  };

  const spinWheel = () => {
    const pickResult = (arr: TTask[], val: number): TTask | null => {
      let clonedArr = [...arr];
      let prio = val;

      while (clonedArr.length > 0) {
        let t = clonedArr.shift();
        if (prio < t!.prio) {
          return t!;
        }

        prio -= t!.prio;
      }

      return null;
    };

    const totalSum = tasks.reduce((prev, curr) => prev + curr.prio, 0);
    const rnd = Math.random() * totalSum; // TODO: maybe use better rng;

    const res = pickResult(tasks, rnd);
    setResult(res);
  };

  return (
    <div>
      <Head>
        <title>Procrastination Roulette</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Box as="header" py="4" bg="blue.100">
        <Container>
          <Heading as="h1" fontSize={["2xl", "3xl"]}>
            Procrastination Roulette
          </Heading>
          <Text fontSize="sm" color="gray.700">
            Add your Tasks and Spin to see what you should be working on!
          </Text>
        </Container>
      </Box>

      <Box as="main" py="4">
        <Container>
          <Stack mb="4">
            <Flex direction={["column", "row"]} gap="2">
              <Input ref={nameRef as any} placeholder="I should do..." />
              <Select ref={prioRef as any} w={["100%", "70%"]}>
                <option value={1}>Very Unimportant</option>
                <option value={2}>Unimportant</option>
                <option value={3}>Indifferent</option>
                <option value={4}>Important</option>
                <option value={5}>Very Important</option>
              </Select>
            </Flex>
            <Button w="100%" colorScheme="blue" onClick={addTask}>
              Add Task
            </Button>
          </Stack>
          <Box mb="4">
            {tasks.length === 0 ? (
              <Alert status="warning">
                <AlertIcon />
                <AlertDescription display="block">
                  I am sure you have to do something... Add some tasks and spin
                  the wheel!
                </AlertDescription>
              </Alert>
            ) : (
              <MotionBox
                variants={containerVariant}
                initial="normal"
                animate="normal"
              >
                <Grid gap={2} templateColumns="1fr 1fr">
                  {tasks.map((t, idx) => (
                    <Task task={t} isResult={t === result} key={idx} />
                  ))}
                </Grid>
              </MotionBox>
            )}
          </Box>
          <Button
            d="block"
            w="100%"
            colorScheme="blue"
            onClick={spinWheel}
            disabled={tasks.length < 2}
          >
            Spin
          </Button>
        </Container>
      </Box>
    </div>
  );
};

export default Home;
